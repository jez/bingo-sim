-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A small playground to learn about profiling Haskell.
--   
--   This package simulates the probability of scoring a bingo at a
--   particular children's carnival game. I've been using it to learn how
--   profiling in Haskell works.
@package bingo-sim
@version 0.0.5.0


-- | This module contains the data types we'll be using, which is really
--   just a way to represent and operate on boards.
--   
--   For our purposes, we only need random boards, so it's sufficient to
--   identify a board position by its index and then represent a board by a
--   bit vector. Compared to a list or some other kind of sequence, this
--   lets us use less space and perform operations on boards in fewer
--   instructions.
--   
--   Since we're using a <a>Word64</a> but only representing boards with 36
--   grid spaces, we only use the 36 least significant bits:
--   <tt>0xf_ffff_ffff</tt>
--   
--   We represent boards in row-major order, so each multiple of 6 bits is
--   a row.
module BingoSim.Board

-- | The type of a 6x6 game board, as a bit sequence. Only the 36 least
--   significant bits are meaningful.
newtype Board
Board :: Word64 -> Board

-- | Check whether there's a bingo, and if so, return the BingoLocation
--   corresponding to where the bingo occured (i.e., which row, column, or
--   diagonal).
--   
--   In the case where there are multiple bingos, returns one of them
--   arbitrarily.
--   
--   <pre>
--   &gt;&gt;&gt; hasBingo (Board 0x123456789)
--   Nothing
--   
--   &gt;&gt;&gt; hasBingo (Board 0x3f)
--   Just Row6
--   </pre>
hasBingo :: Board -> Maybe BingoLocation

-- | An enum of where a bingo could occur on a 6x6 board.
data BingoLocation

-- | Top left to bottom right
Dia1 :: BingoLocation

-- | Top right to bottom left
Dia2 :: BingoLocation

-- | Top row
Row1 :: BingoLocation
Row2 :: BingoLocation
Row3 :: BingoLocation
Row4 :: BingoLocation
Row5 :: BingoLocation

-- | Bottom row
Row6 :: BingoLocation

-- | Far left column
Col1 :: BingoLocation
Col2 :: BingoLocation
Col3 :: BingoLocation
Col4 :: BingoLocation
Col5 :: BingoLocation

-- | Far right column
Col6 :: BingoLocation

-- | Diagonal from top left to bottom right
dia1 :: Word64

-- | Diagonal from top right to bottom left
dia2 :: Word64

-- | Top row
row1 :: Word64

-- | Second row from top
row2 :: Word64

-- | Third row from top
row3 :: Word64

-- | Fourth row from top
row4 :: Word64

-- | Fifth row from top
row5 :: Word64

-- | Bottom row
row6 :: Word64

-- | Far left column
col1 :: Word64

-- | Second column from left
col2 :: Word64

-- | Third column from left
col3 :: Word64

-- | Fourth column from left
col4 :: Word64

-- | Fifth column from left
col5 :: Word64

-- | Far right column
col6 :: Word64
instance GHC.Show.Show BingoSim.Board.BingoLocation
instance GHC.Classes.Eq BingoSim.Board.BingoLocation
instance Text.Printf.PrintfArg BingoSim.Board.Board
instance GHC.Classes.Eq BingoSim.Board.Board
instance GHC.Show.Show BingoSim.Board.Board


-- | This is a port of <a>xoshiro256**</a> from C to Haskell. The
--   documentation and comments below come from the original C sources.
--   
--   Written in 2018 by David Blackman and Sebastiano Vigna (vigna@acm.org)
--   
--   To the extent possible under law, the author has dedicated all
--   copyright and related and neighboring rights to this software to the
--   public domain worldwide. This software is distributed without any
--   warranty.
--   
--   See <a>http://creativecommons.org/publicdomain/zero/1.0/</a>.
module BingoSim.Prng

-- | The state of the generator.
--   
--   The state must be seeded so that it is not everywhere zero. If you
--   have a 64-bit seed, we suggest to seed a splitmix64 generator and use
--   its output to fill s.
--   
--   In Haskell, we've made this type opaque. See <a>mkState</a> to
--   construct a <a>State</a>.
data State

-- | Create an initial state from a seed.
--   
--   Raises an exception if the initial seed is all zeros.
--   
--   <pre>
--   &gt;&gt;&gt; mkState 0 0 0 0
--   *** Exception: The state must be seeded so that it is not zero everywhere.
--   
--   &gt;&gt;&gt; mkState 1 2 3 4
--   mkState 1 2 3 4
--   </pre>
mkState :: Word64 -> Word64 -> Word64 -> Word64 -> State

-- | This is xoshiro256** 1.0, our all-purpose, rock-solid generator. It
--   has excellent (sub-ns) speed, a state (256 bits) that is large enough
--   for any parallel application, and it passes all tests we are aware of.
--   
--   For generating just floating-point numbers, xoshiro256+ is even
--   faster.
--   
--   <pre>
--   &gt;&gt;&gt; let state = mkState 1 2 3 4
--   
--   &gt;&gt;&gt; next state (\rand _state' -&gt; rand)
--   11520
--   </pre>
--   
--   Note: When porting to Haskell, we've explicitly chosen to make the API
--   of <a>next</a> in CPS-style (i.e., using a callback) to avoid always
--   allocating a tuple for the result.
--   
--   If you'd rather just have a tuple, you can pass <tt>(,)</tt> as the
--   callback:
--   
--   <pre>
--   &gt;&gt;&gt; next state (,)
--   (11520,mkState 7 0 262146 211106232532992)
--   </pre>
next :: State -> (Word64 -> State -> a) -> a

-- | This is the jump function for the generator. It is equivalent to 2^128
--   calls to next(); it can be used to generate 2^128 non-overlapping
--   subsequences for parallel computations.
--   
--   Note: This function is not yet implemented in Haskell.
jump :: State -> State

-- | This is the long-jump function for the generator. It is equivalent to
--   2^192 calls to next(); it can be used to generate 2^64 starting
--   points, from each of which jump() will generate 2^64 non-overlapping
--   subsequences for parallel distributed computations.
--   
--   Note: This function is not yet implemented in Haskell.
longJump :: State -> State
instance GHC.Show.Show BingoSim.Prng.State


-- | Simulates the likelyhood of winning a children's carnival bingo game.
--   
--   The game itself works like this:
--   
--   <ol>
--   <li>There's a 6 x 6 grid, each with it's own special character
--   identifying it.</li>
--   <li>There are 36 tiles, one for each grid space.</li>
--   <li>Initially, all tiles are face down.</li>
--   <li>To play, a contestant chooses 15 of the 36 tiles and flips them
--   over.</li>
--   <li>The contestant places the flipped tiles onto the correct
--   spots.</li>
--   <li>If placing the 15 tiles forms a bingo in any row, column, or full
--   diagonal, it's a win. Otherwise, it's a loss.</li>
--   </ol>
--   
--   Our question is: if one of our friends wins this game, how lucky
--   should they consider themself? Rather than compute the probability
--   exactly, here we run a simulation to approximate the exact probability
--   of a win.
--   
--   To represent a bingo board and the operations on them, we've created
--   the <a>Board</a> type, which is a bit vector representing the grid in
--   row major order where a <tt>1</tt> means that a tile was placed on
--   that grid space. There is also a <a>hasBingo</a> helper to figure out
--   whether a <a>Board</a> has a bingo.
--   
--   This module has the logic to actually carry out the simulation:
--   <a>runSimulation</a>
--   
--   (Note: This module is basically the <tt>Main</tt> module, except I
--   couldn't figure out how to generate Haddock documentation for an
--   executable target, not a library target.)
module BingoSim.Simulation

-- | Run the entire simulation, consisting of <tt>trials</tt> trials.
--   
--   Prints the results to stdout when done.
--   
--   <pre>
--   &gt;&gt;&gt; runSimulation 100000
--   Trials:   100000
--   Bingos:   3615
--   Hit rate: 0.03615
--   </pre>
--   
--   This function is called directly by the <tt>bingo-sim</tt>
--   executable's <tt>main</tt> method, so you can get the same effect by
--   running <tt>bingo-sim</tt> at the command line, instead of the Haskell
--   REPL:
--   
--   <pre>
--   ‚ùØ bingo-sim 100000
--   Trials:   100000
--   Bingos:   3615
--   Hit rate: 0.03615
--   </pre>
runSimulation :: Int -> IO ()

-- | Generate a random board.
--   
--   Uses a somewhat contrived strategy:
--   
--   <ol>
--   <li>Start with a bit sequence with fifteen 1's (<tt>0x7fff</tt>).</li>
--   <li>Use <a>Fisher-Yates</a> to shuffle the individual bits among the
--   lower 36 bits of the sequence.</li>
--   </ol>
--   
--   This is much faster than the naive strategy of:
--   
--   <ol>
--   <li>Generate the numbers <tt>0</tt> to <tt>35</tt> in a list and
--   shuffle them.</li>
--   <li>Take the first 15, to represent picking 15 random tiles.</li>
--   <li>Flip on the bits corresponding to each tile we picked.</li>
--   </ol>
--   
--   The Fisher-Yates on bits approach is faster because we don't have to
--   generate a linked list of thunks and instead can operate on a single
--   64-bit word.
--   
--   The sacrifice is that the naive strategy nearly exactly matches our
--   intuition for how this game works in the real world.
randomBoard :: State -> IO (Board, State)

-- | Implements <a>Fisher-Yates</a> at the bit level for a <a>Board</a>.
--   
--   Uses recursion to swap the current bit into place, from most to least
--   significant.
shuffleBits :: State -> Board -> Int -> (Board, State)

-- | Helper for swapping two specific bits.
--   
--   Graciously taken from Sean Eron Anderson's <a>Bit Twiddling Hacks</a>,
--   specialized to the case of a length 1 range of bits.
swapBits :: Word64 -> Int -> Int -> Word64
